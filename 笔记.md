### 2018-9-29
## 一. python 语言特性
* 1.为什么学习Python？
	* 语言本身简洁，优美,功能强大，跨平台兼容性非常好，常被用作“胶水语言”，从桌面应用,web开发,自动化测试运维，爬虫，人工智能，大数据处理都有广泛应用
	* Python是一种解释型语言。这就是说，与C语言和C的衍生语言不同，Python代码在运行之前不需要编译。其他解释型语言还包括PHP和Ruby。
	* Python是动态类型语言，指的是你在声明变量时，不需要说明变量的类型。你可以直接编写类似x=111和x="I'm a string"这样的代码，程序不会报错。
	* Python非常适合面向对象，代码编写快，让困难的事情变得容易，因此程序员可以专注于算法和数据结构的设计，而不用处理底层的细节
* 2.Python和Java、PHP、C、C#、C++等其他语言的对比？
	* C语言由于其底层操作特性和历史的积累，在嵌入式领域是当之无愧的王者
	* C++的优点：1.可扩展性强3.可移植性4.面向对象的特性5.强大而灵活的表达能力和不输于C的效率6.支持硬件开发
	* PHP跨平台，性能优越，跟Linux/Unix结合比跟Windows结合性能强45%，开发成本低，PHP 5已经有成熟的面向对象体系，适合开发大型项目淘宝网、Yahoo、163、Sina等等大型门户，很多选用PHP来作为他们的开发语言
	* JAVA的优点：1.简单性2.面向对象性（面向对象的程度可以达到95%）3.健壮性4.跨平台性5.高性能（自动垃圾回收机制）6.多线程7.动态性8.安全性
	* C#也是一种特殊的解释性语言。C#的特点是运行在一个容器中.netframework, 只有平台提供这个容器,C#的程序都可以运行,这个就提供了跨平台的能力,而且垃圾回收不用你操心,c#完全面向对象，支持分布式，跟Java类似，C#代码经过编译后，成为了一种IL（中间语言）。在运行时，再把IL编译为平台专用的代码。高性能性和多线程性。
* 3.简述解释型和编译型编程语言的区别？
	* 1.解释型语言，是在运行的时候将程序翻译成机器语言，所以运行速度相对于编译型语言要慢。
	* 2.编译型语言在程序执行之前，有一个单独的编译过程，将程序翻译成机器语言，以后执行这个程序的时候，就不用再进行翻译了。
	* 3.C/C++ 等都是编译型语言，而python，PHP，Java，C#等都是解释型语言。
	* 4.脚本语言一般都有相应的脚本引擎来解释执行。 他们一般需要解释器才能运行。JAVASCRIPT,ASP,PHP,PERL,Nuva都是脚本语言。C/C++编译、链接后，可形成独立执行的exe文件。
* 4.Python解释器种类以及特点？
	* CPython：这个解释器是用C语言开发的，所以叫CPython，在命名行下运行python，就是启动CPython解释器，CPython是使用最广的Python解释器。
	* Jython：Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。
	* IPython：IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的，好比很多国产浏览器虽然外观不同，但内核其实是调用了IE
* 5.计算机存储信息的最小单位，称之为位（bit），音译比特，二进制的一个“0”或一个“1”叫一位。 
	* 计算机存储容量基本单位是字节（Byte），音译为拜特，8个二进制位组成1个字节，一个标准英文字母占一个字节位置，一个标准汉字占二个字节位置。
	* 8bit=1B(字节)
	1024B=1K（千）B 
	1024KB=1M（兆）B 
	1024MB=1G（吉）B 
	1024GB=1T（太）B 
* 6.请至少列举5个 PEP8 规范（越多越好).
	- 1缩进。4个空格的缩进（编辑器都可以完成此功能），不使用Tab，更不能混合使用Tab和空格。
	- 2每行最大长度79，换行可以使用反斜杠，最好使用圆括号。换行点要在操作符的后边敲回车。
	- 3类和top-level函数定义之间空两行；类中的方法定义之间空一行；函数内逻辑无关段落之间空一行；其他地方尽量不要再空行。
	- 4块注释，在一段代码前增加的注释。在‘#’后加一空格。段落之间以只有‘#’的行间隔
	- 5各种右括号前不要加空格。
	- 6逗号、冒号、分号前不要加空格。
	- 7函数的左括号前不要加空格。如Func(1)。
	- 8序列的左括号前不要加空格。如list[2]。
	- 9操作符左右各加一个空格，不要为了对齐增加空格。
	- 10函数默认参数使用的赋值符左右省略空格。
	- 11不要将多句语句写在同一行，尽管使用‘；’允许。
	- 12if/for/while语句中，即使执行语句只有一句，也必须另起一行。
	- 13类的方法第一个参数必须是self，而静态方法第一个参数必须是cls。

** !!!对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象（即可变类型和不可变类型）。在python中，strings, tuples, 和numbers是不可更改的对象，而 list, dict, set 等则是可以修改的对象。
**

- 对不可变类型的变量重新赋值，实际上是重新创建一个不可变类型的对象，并将原来的变量重新指向新创建的对象（如果没有其他变量引用原有对象的话（即引用计数为0），原有对象就会被回收）。	

* 7.代码实现如下转换:
	* 1.二、八、十六进制转换成十进制
	```
	先将其转换为字符串，再使用int函数，指定进制转换为十进制。
	int("0b1111011",2) # 123
	int("011",8) # 9
	int("0x12",16) # 18
	```
	* 2.十进制转换成二进制
	```
	bin(18) # 0b10010
	```
	* 3.十进制转换成八进制
	```	
	oct(30) # 0o36
	```
	* 4.十进制转换成十六进制
	```
	hex(87) # 0x57
	```
* 8.实现[‘1’,’2’,’3’]变成[1,2,3]
	```
	a=[‘1‘,‘2‘,‘3‘]
	b=[int(i) for i in a]
	print(b)  # [1,2,3]
	```
* 9.python递归的最大层数？
	* 得到的最大数为999，1000及以后的数值就是报错了,所以最大递归层数是999层
	```
	def fab(n):
		if n == 1:
			return 1
		else:
			return fab(n-1)+ n

	print (fab(999))
	```
* 10.Python 字典 fromkeys() 函数用于创建一个新字典，以序列 seq 中元素做字典的键，value 为字典所有键对应的初始值,默认为None。
	```
	#!/usr/bin/python
	# -*- coding: UTF-8 -*-
 
	seq = ('Google', 'Runoob', 'Taobao')
	或者seq = ['Google', 'Runoob', 'Taobao']
 
	dict = dict.fromkeys(seq)
	print "新字典为 : %s" %  str(dict)
 
	dict = dict.fromkeys(seq, 10)
	print "新字典为 : %s" %  str(dict)

	# 结果
	新字典为 :{'Google':None, 'Runoob':None, 'Taobao':None}
	新字典为 :{'Google':10, 'Runoob':10, 'Taobao':10}
	![](https://i.imgur.com/L9kFskE.jpg)
	```
	* 使用fromkeys()创建出来的字典，value值只要是list、dict等可变类型，改变其中某个key的值，其他的key的value值也会跟着改变；而如果value值是number、str不可变类型时，改变其中某个key的值，其他的key的value值并不会跟着改变。
	* 以fromkeys()方法创建的字典，所有的引用其实都是指向的同一个object。如果value是一个可变类型，由于Python语言的内存机制，修改值并不会改变value的内存地址；如果value是不可变类型，修改值会改变value的内存地址，这个结果与python的内存机制是一致的。
	```
	创建v1
	>>> v1 = dict.fromkeys(['k1', 'k2'], [])
	>>> v1
	{'k1': [], 'k2': []}
	>>> id(v1['k1'])
	4314672072
	>>> id(v1['k2'])
	4314672072
	>>> v1['k1'] is v1['k2']
	True
	
	# 修改v1
	>>> v1['k1'].append(666)
	>>> v1
	{'k1': [666], 'k2': [666]}
	>>> id(v1['k1'])
	4314672072
	>>> id(v1['k2'])
	4314672072
	
	# 再次修改v1
	>>> v1['k1'] = 777
	>>> v1
	{'k1': 777, 'k2': [666]}
	>>> id(v1['k1'])
	4309472080
	>>> id(v1['k2'])
	4314672072
	```
* 11.Python的函数参数传递
	* 函数参数传递是值传递还是引用传递?要分情况：
	* **a.不可变参数用值传递：**
	像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象
	*** b.可变参数是用引用传递的**
	比如像列表，字典这样的对象是通过引用传递，和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变.
	* 当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改.
* 12.lambda argument_list: expression匿名函数
	* argument_list是参数列表，可以是a, b ；a=1, b=2； \*args； \*\*kwargs ；a, b=1, \*args
	* expression是一个关于参数的表达式,表达式只能是单行；1；None；a + b；sum(a)；if a >10 else 0
	* 执行语句add=lambda x, y: x+y，定义了加法函数lambda x, y: x+y，并将其赋值给变量add，这样变量add便成为具有加法功能的函数。例如，执行add(1,2)，输出为3。
	```
	1.
	def num():
    	return [lambda x:i*x for i in range(4)]
	# 此处的表达式i*x的i不是循环的i值，因为匿名函数的参数列表没有i的参数传进去，
		此i值会从最近的调用处取得值，即先局部变量再全局变量取值
	print [m(2) for m in num()]   # [6,6,6,6]
	print(m(2) for m in num())   # <generator object <genexpr> at 0x0000000000B2FA40> 
									为一个有id地址的元组
	print(list(m(2) for m in num()))   # [6,6,6,6]
	
	2.
	def num():
    	j=4
    	return [lambda x:j*x for i in range(4)]
	# 循环完成后，下面的num()调用时，先局部变量找到j值，即表达式的值不从循环中获取
	print [m(2) for m in num()]   # [8,8,8,8] 此时为4*2
	
	3.
	def num1():
    	return [lambda x, i = i:i*x for i in range(4)]
	# 每次循环将i值传给参数列表，表达式为  0*x,1*x,2*x,3*x
	print [m(2) for m in num1()]   # [0,2,4,6]

	4.
	def num1():
    	return [lambda x, j=i:j*x for i in range(4)]
	print [m(2) for m in num1()]   #  [0,2,4,6]
	```
* 13.求结果
	```
	a. 1 or 2  # 1 
	-- 2 or 3  # 2
	b. 1 and 2  # 2
	c. 1 < (2==2)  # False，先圆括号为true，值为1，1<1为false
	d. 1 < 2 == 2  # True
	e. 1 < 2 == 1  # False，先判断1<2为true，再判断2==1位false，相当于and，故结果为false
	f. 0 and 2 or 1  #1
	
	0 or False  #  False
	False or 0  #  0
	False or 2  #  2
	
	2 and True  #  True
	True and 2  #  2
	```
* 14.ascii、unicode、utf-8、gbk 区别？
	* ASCII码使用一个字节编码，所以它的范围基本是只有英文字母、数字和一些特殊符号 ，只有256个字符。
	* Unicode的字符时，通常会用“U+”然后紧接着一组**十六进制**的数字来表示这一个字符,Unicode能够表示全世界所有的字节
	* GBK是只用来编码汉字的，GBK全称《汉字内码扩展规范》，使用双字节编码,一个汉字占位2字节。
	* UTF-8是一种针对Unicode的可变长度字符编码，又称万国码，用1到6个字节编码UNICODE字符。
* 15.字节码和机器码的区别？
	* 字节码：字节码是一种中间状态（中间码）的二进制代码（文件），但与特定机器码无关，需要直译器转译后才能成为机器码的中间代码。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令（机器码）。
	* 机器码：机器码就是电脑CPU直接读取运行的机器指令，并且执行速度最快的代码。
* 16.三元运算规则以及应用场景：
	* 1.三元运算符的功能与“if...else”流程语句一致，它在一行中书写，代码非常精练、执行效率更高。
	```
	(expr1) ? (expr2) : (expr3);
	解释：如果条件“expr1”成立，则执行语句“expr2”，否则执行“expr3”。

	if(expr1):
    	expr2
	else:
    	expr3
	```
	* 2.三元运算符可以扩展使用，当设置的条件成立或不成立，执行语句都可以不止一句
	```
	(expr1) ? (expr2).(expr3) : (expr4).(expr5);

	多个执行语句用字符串运算符号（“.”）连接起来，各执行语句用小角括号包围起来
	以表明它是一个独立而完整的执行语句。
	```
* 17.Python其实有3个方法,即**静态方法(staticmethod)**,**类方法(classmethod)**和**实例方法**
	```
	def foo(x):
    	print "executing foo(%s)"%(x)  #  普通函数

	class A(object):
    	def foo(self,x):
        	print "executing foo(%s,%s)"%(self,x)  #  实例方法

    	@classmethod
    	def class_foo(cls,x):
        	print "executing class_foo(%s,%s)"%(cls,x)  # 类方法

    	@staticmethod
    	def static_foo(x):
        	print "executing static_foo(%s)"%x  # 静态方法

	a=A()

	```
	* 1.静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用a.static_foo(x)或者A.static_foo(x)来调用.
	* 2.这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.

| \\      | 实例方法     | 类方法            | 静态方法    |
| :------ | :------- | :------------- | :-------------- |
| a = A() | a.foo(x) | a.class_foo(x) | a.static_foo(x) |
| A       | 不可用      | A.class_foo(x) | A.static_foo(x) |
* 18.Python自省,就是面向对象的语言所写的程序在运行时,所能知道对象的类型，简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().
	```
	a = [1,2,3]
	b = {'a':1,'b':2,'c':3}
	c = True
	print type(a),type(b),type(c) # <type 'list'> <type 'dict'> <type 'bool'>
	print isinstance(a,list)  # True
	```
* 19.列举 Python2和Python3的区别？
	* 1.print：在 Python 2 中， print 被视为一个语句而不是一个函数,直接print空格加上字符串即可输出；
		在Python3，print（）会被显式地视为一个函数，需要加圆括号输出。
	* 2.整数的除法：在 Python 2 中，您键入的任何不带小数的数字，将被视为整数的编程类型（5/2=2，5./2=2.5，5.0/2=2.5）。
		在 Python 3 中的这种修改使得整数除法更为直观（5/2=2.5，求商才是整数的商5//2=2）
	* 3.Python3支持 Unicode：Python 2 默认使用 ASCII 字母表，要使用更通用和更强大的Unicode字符编码，需要加u（u“Hello”）；
		Python 3 默认使用 Unicode；
	* 4.python2中为正常显示中文，引入coding声明，python3中不需要；
	* 5.python2中是raw_input()函数，python3中是input()函数；
	* 6.python2 range(1,10)返回列表，python3中返回迭代器，节约内存
	* 7.事实上 Python 2.7 将在 2020 年失去后续的支持，Python 3 将继续开发更多的功能和修复更多的错误。
* 20.Python3和Python2中 int 和 long的区别？long整数类型被Python3废弃，统一使用int。
* 21.xrange和range的区别？
	* range([start,] stop[, step])，根据start与stop指定的范围以及step设定的步长，生成一个序列的列表。type(range)`<type 'list'>`
	* xrange则不会直接生成一个list，而是一个生成器。type(xrange)`<type ‘xrange‘>`
	* range返回的是一个list对象，而xrange返回的是一个生成器对象(xrange object)。每次调用返回其中的一个值，内存空间使用极少，因而性能非常好。
	* 注意：Python 3.x已经去掉xrange，全部用range代替。
* 22.文件操作时：xreadlines和readlines的区别？
	* read        读取整个文件
	* readline    读取下一行,使用生成器方法,一次取出一行
	* readlines   读取整个文件到一个迭代器（即列表中）以供我们遍历
	* 二者使用时相同，但返回类型不同，xreadlines返回的是一个生成器，readlines返回的是list
* 23.列举布尔值为False的常见值？
	* 0，None，[]，{}，()，''(空值)
* 24.字符串、列表、元组、字典每个常用的5个方法？
	* 1.字符串
	```
	words = ‘today is a wonderfulday‘
	print(words.strip(‘today‘))
	#如果strip方法指定一个值的话，那么会去掉这个值，如果为空，去掉此字符串首尾的空格
	print(words.count(‘a‘))#统计字符串出现的次数
	print(words.index(‘z‘))#找下标如果元素不找不到的话，会报错
	print(words.find(‘z‘))#找下标，如果元素找不到的话，返回-1
	print(words.replace(‘day‘,‘DAY‘))#字符串替换
	print(words.startswith(‘http‘))#判断是否以某个字符串开头
	print(words.endswith(‘.jpg‘))#判断是否以某个字符串结尾
	print(words.upper())#将字符串变成大写
	print(words.lower())#将字符串变成小写
	```
	* 2.列表
	```
	value_start = sample_list[0]  #得到列表中的某一个值
	end_value = sample_list[-1]  #得到列表中的某一个值
	del sample_list[0]  #删除列表的第一个值
	list_length = len(sample_list)  #得到列表的长度
	for element in sample_list:  #列表遍历
    	print(element)
	```
	* 3.元组:元组也是一个list，他和list的区别是元组的元素无法修改
	```
	tuple1 = (2,3,4,5,6,4,7)
	print(type(tuple1))
	print(tuple1[:7])
	print(tuple1[:5:-1])
	for i in range(6):
    	print(tuple1[i])
	for i in tuple1:
    	print(i)
	```
	* 4.字典
	```
	D={‘ob1‘:‘computer‘, ‘ob2‘:‘mouse‘, ‘ob3‘:‘printer‘}
	D.get(key, 0)  #同dict['key']，多了个没有对应的键则返回缺省值，0。dict['key']没有则抛异常
	D.has_key(key)      #有该键返回TRUE，否则FALSE
	D.keys()            #返回字典键的列表
	D.update(dict2)     #增加合并字典
	D.copy()            #拷贝字典
	dict.items()        #返回可遍历的(键, 值) 元组数组(列表)。
		dict = {'Google': 'www.google.com', 'Runoob': 'www.runoob.com', 
				'taobao': 'www.taobao.com'}
		print "字典值 : %s" %  dict.items()
		# [('Google', 'www.google.com'), ('taobao', 'www.taobao.com'), 
			('Runoob', 'www.runoob.com')]
	```
* 25.字符串格式化:%和.format
	* 1.%最烦人的是它无法同时传递一个变量和元组,
	```
	>>> print("%6.3f" % 2.3)
 	2.300  # 第一个 % 后面的内容为显示的格式说明，6 为显示宽度，3 为小数点位数，f 为浮点数类型
 			  第二个 % 后面为显示的内容来源，输出结果右对齐，2.300 长度为 5，故前面有一空格
	"hi there %s" % name
	但是,如果name恰好是(1,2,3),它将会抛出一个TypeError异常.为了保证它总是正确的,你必须这样做:
	"hi there %s" % (name,)   # 提供一个单元素的数组而不是一个参数
	但是有点丑..format就没有这些问题.
	```
	* 2.format函数是高级字符串格式化,基本语法是通过 {} 和 : 来代替以前的 % 。
	形式为{n}(n为整数)的占位符将被format()方法第n个参数所代替,n从0开始;
	形式为{name}的占位符将被参数中为name的参数所替代;
	```
	>>>"{} {}".format("hello", "world")         # 不设置指定位置，按默认顺序
	'hello world'
	 
	>>> "{0} {1}".format("hello", "world")      # 设置指定位置
	'hello world'
	 
	>>> "{1} {0} {1}".format("hello", "world")  # 设置指定位置
	'world hello world'

	>>>print("网站名：{name}, 地址 {url}".format(name="菜鸟教程", url="www.runoob.com"))
	网站名：菜鸟教程, 地址 www.runoob.com 

	# 通过字典设置参数
	>>>site = {"name": "菜鸟教程", "url": "www.runoob.com"}
	>>>print("网站名：{name}, 地址 {url}".format(**site))
	
	>>>person = {'first': 'Jean-Luc', 'last': 'Picard'}
	>>>'{p[first]} {p[last]}'.format(p=person)	
	Jean-Luc Picard

	>>>'{:.5}'.format('xylophone')  # 冒号后面的点加字符位数声明（5位）
	xylop
	
	千分位(18后面的逗号表示)、浮点数、填充字符、对齐的组合使用：
	# :冒号+a填充+右对齐+固定宽度18+浮点精度.2+浮点数声明f
	输入： '{:a>18,.2f}'.format(70305084.0)  
	输出：'aaaaaa70,305,084.00'

	>>>data = [4, 8, 15, 16, 23, 42]
	>>>'{d[4]} {d[5]}'.format(d=data)
	23 42
	```
* 26.迭代器和生成器
	* 迭代器就是可以让你**迭代可迭代对象**的对象。从可迭代对象的第一个元素开始访问，直到所有元素被访问结束。其优点是不需要事先准备好整个迭代过程中的所有元素，仅在迭代到某个元素时才开始计算该元素。适合遍历比较巨大的可迭代对象。
	* 1.生成器是迭代器的一种,但是你只能**迭代它们一次**.原因很简单,因为它们不是全部存在内存里,它们只在要调用的时候在内存里生成，不像一般函数在生成值后退出，生成器函数在生成值后会自动挂起并暂停他们的执行状态。（**带有Yield的函数为生成器**，Yield的用法和关键字return差不多）：
	* 2.问： 将列表生成式中[]改成() 之后数据结构是否改变？
		答案：是，数据从列表变为生成器

	```
	列表生成式
	>>> mylist = [x*x for x in range(3)]
	>>> for i in mylist:
	...    print(i)
	0
	1
	4
	
	生成器
	>>> mygenerator = (x*x for x in range(3))
	>>> for i in mygenerator:
	...    print(i)
	0
	1
	4
	生成器和迭代器的区别就是用()代替[],还有你不能用for i in mygenerator第二次调用生成器:
	首先计算0,然后会在内存里丢掉0去计算1,直到计算完4.
	```
	* 3.extend()是一个列表对象的方法,它可以把一个迭代对象添加进列表.
	```
	>>> a = [1, 2]
	>>> b = [3, 4]
	>>> a.extend(b)
	>>> print(a)
	[1, 2, 3, 4]
	```
* 27.pass的作用？
	* 1.空语句 do nothing
	```
	if true:
	    pass #do nothing
	else:
	    pass #do something
	```
	* 2.保证格式完整
	```
	def func():
    	pass
	```
	* 3.保证语义完整
	```
	while True:
    	pass
	```
* 28.\*arg和**kwarg作用
	* 1.*args：可以理解为只有一列的表格，长度不固定。
	* 2.**kwargs：可以理解为字典，长度也不固定。
	* 3.当调用函数时你也可以用`*`和`**`语法.例如:
	```
	>>> def print_three_things(a, b, c):
	...     print 'a = {0}, b = {1}, c = {2}'.format(a,b,c)
	...
	>>> mylist = ['aardvark', 'baboon', 'cat']
	>>> print_three_things(*mylist)
	
	a = aardvark, b = baboon, c = cat
	```
	就像你看到的一样,它可以**传递列表(或者元组)的每一项并把它们解包**.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用.
* 29.is和==的区别
	* 1.is是对比id地址，==是对比值
	* 2.is也被叫做同一性运算符，这个运算符比较判断的是对象间的唯一身份标识，也就是id是否相同
	```
	>>> x = y = [4,5,6]
	>>> z = [4,5,6]
	>>> x == y
	True
	>>> x == z   #  对比值
	True
	>>> x is y
	True
	>>> x is z   #  对比id地址
	False
	>>>
	>>> print id(x)
	3075326572
	>>> print id(y)
	3075326572
	>>> print id(z)
	3075328140
	```
	* is同一性运算符只有数值型int和字符串型str的情况下，a is b才为True，当a和b是tuple（元组），list，dict或set型时，a is b为False
* 30.简述Python的深浅拷贝以及应用场景？
	import copy
	字面理解：浅拷贝指仅仅拷贝数据集合的第一层数据，深拷贝指拷贝数据集合的所有层。所以对于只有一层的数据集合来说深浅拷贝的意义是一样的，比如**字符串，数字**，还有两层（索引一层，值一层）的**字典、列表、元组**等.
	* 1.浅拷贝：copy.copy
	* 2.深拷贝：copy.deepcopy
	* 3.深拷贝的时候python将字典的所有数据在内存中新建了一份，所以如果你修改新的模版的时候老模版不会变。相反，在浅copy 的时候，python仅仅将最外层的内容（即仅拷贝索引，未拷贝值）在内存中新建了一份（索引）出来，字典第二层的列表并没有在内存中新建，所以你修改了新模版，默认模版也被修改了。
* 31.Python垃圾回收机制？
	Python的GC模块主要运用了“引用计数”（reference counting）来跟踪和回收垃圾。
	* 1.引用计数--跟踪和回收垃圾
		* 原理：当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1；当对象的引用计数**减少为0时**，就意味着对象已经没有被任何人使用了，可以删除将其所占用的内存释放了。
		* 引用计数有一个最大的优点，即“**实时性**”，任何内存，一旦没有指向它的引用，就会立即被回收。而其他的垃圾收集计数必须在某种特殊条件下（比如内存分配失败）才能进行无效内存的回收。
		* 引用计数机制致命的弱点就是**循环引用（也称交叉引用）**：
		循环引用可以使一组对象的引用计数不为0，然而这些对象实际上并没有被任何外部对象所引用，它们之间只是相互引用。这意味着不会再有人使用这组对象，应该回收这组对象所占用的内存空间，然后由于相互引用的存在，每一个对象的引用计数都不为0，因此这些对象所占用的内存永远不会被释放。比如：
		```
		a = []
		b = []
		a.append(b)
		b.append(b)
		print(a)   # [[[...]]]
		print(b)   # [[...]]
		```
	* 2.标记-清除--解决容器对象可能产生的循环引用的问题
		* 如果两个对象的引用计数都为1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被回收的，也就是说，它们的引用计数虽然表现为非0，但实际上有效的引用计数为0。我们必须先将循环引用摘掉，那么这两个对象的有效计数就现身了。
		* 我们不改动真实的引用计数，而是将集合中对象的引用计数复制一份副本，改动该对象引用的副本。对于副本做任何的改动，都不会影响到对象生命走起的维护。
	* 3.分代回收--以**空间换取时间**来进一步提高垃圾回收的效率
		* 原理：将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个“代”，垃圾收集的频率随着“代”的存活时间的增大而减小。也就是说，活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。
* 32.Python内存管理机制，Python对**int类型和较短的字符串**（其他如浮点数或者长字符串不包括）进行了缓存，无论声明多少个值相同的变量，实际上都指向同个内存地址，即id地址相同。
	Python缓冲池中整数范围为**[-5，256]**,也就是说，当创建的整数对象在**大于等于-5小于等于256**时，直接从缓冲池中去，故每个id值相同，如果不在此范围则创建该对象且id值不同。
	```
	>>> i = 5
	>>> j = 5
	>>> id(i)
	140656970352216
	>>> id(j)
	140656970352216
	>>> k = 5
	>>> id(k)
	140656970352216

	>>> i = 2.5
	>>> id(i)
	140564351733040
	>>> j = 2.5
	>>> id(j)
	140564351733016

	```
* 33.列举常见的内置函数？Python内置函数就是python标准库里（语言自身携带的）函数（公共函数）。
	* 1.abs()    (absolute value)此函数返回数字的绝对值。
	```
	a = 5
	b = -10
	print(abs(a))  #输出5
	print(abs(b))  #输出10
	```
	* 2.all()     此函数用于判断给定的可迭代参数 iterable 中的所有元素是否：都不为 0、都不为False 或者**可迭代参数iterable都为空**，如果是返回 True,否则返回 False。
	```
	print(all([‘a‘, ‘b‘, ‘c‘, ‘d‘]))  # True
	print(all([‘a‘, ‘b‘, ‘‘, ‘d‘]))   # False ，有一个空值
	print(all([0, 1,2, 3]))           # False  ，有0值
	print(all([]))  				  # True  ,可迭代参数为空也是True
	print(all(())) 				   # True
	```
	* 3.any()     函数用于判断给定的可迭代参数 iterable 是否全部为空对象，如果都为空、都为0、或者都为false，则返回 False，如果不都为空、不都为0、不都为false，则返回 True。
	```
	print(any([‘a‘, ‘b‘, ‘c‘, ‘d‘]))  # True
	print(any([‘a‘, ‘b‘, ‘‘, ‘d‘]))   # True
	print(any([0, 1,2, 3]))           # True
	print(any([0,0,0,0])) 	 	   # False
	print(any([])) 				   # False
	print(any(())) 				   # False
	```
	* 4.bool()    函数用于将给定参数转换为布尔类型，如果**没有参数，返回 False**。
	* 5.int()    函数用于将一个字符串会数字转换为十进制整型，int('11'，2) # 3。
	* 6.bin()     函数将一个整数 int 或者长整数 long int 转换为二进制的字符串（0b开头）。
	* 7.oct()    函数将一个整数转换成8进制字符串（0开头）。
	* 8.hex()    函数用于将10进制整数转换成16进制字符串（0x开头）。
	* 9.complex(real,imag)     函数用于创建一个值为 real + imag * j 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数。
	```
	print(complex(1, 2))    #(1 + 2j)
	print(complex(1))       #(1 + 0j)
	print(complex("3")) 	#(3+0j)
	```
	* 10.open()    函数用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。
	* 11.divmod()    函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。
	```
	>>> divmod(4,2)
	(2, 0)
	>>> divmod(8,3)
	(2, 2)
	```
	* 12.eval()    函数用来执行一个字符串表达式，并返回表达式的值，即将字符串变为数字类型或者字符串变为可执行语句
	```
	>>> eval('5')
	5
	>>> eval('3+5')
	8
	```
	* 13.float()    函数用于将整数和字符串转换成浮点数。
	* 14.id()       函数用于获取对象的内存id地址。
	* 15.len()    方法返回对象（字符、列表、元组等）长度或项目个数。
	* 16.**dict()**     函数用于创建一个字典。print(dict(a=‘a‘,b=‘b‘)) #{‘b‘: ‘b‘, ‘a‘: ‘a‘}
	* 17.**list()**    方法用于将元组转换为列表。
	* 18.**tuple()**   函数将列表转换为元组。
	* 19.**set() **   函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。
	```
	set([iterable])    返回新的集合对象。
	>>>x = set('runoob')
	>>> y = set('google')
	>>> x, y
	(set(['b', 'r', 'u', 'o', 'n']), set(['e', 'o', 'g', 'l']))   # 重复的被删除
	>>> x & y         # 交集
	set(['o'])
	>>> x | y         # 并集
	set(['b', 'e', 'g', 'l', 'o', 'n', 'r', 'u'])
	>>> x - y         # 差集
	set(['r', 'b', 'u', 'n'])

	list1=[1,2,3,4,2,3]
	s=set(list1)
	print(s)    	# set([1,2,3,4]),没有重复项的集合对象
	print list(s)   # [1,2,3,4],将重复的列表去除重复项后的列表

	使用add(key)往集合中添加元素，重复的元素自动过滤：
	s.add(5)  		#set([1, 2, 3, 4， 5])
	通过remove(key)方法可以删除元素：
	s.remove('2')	 #set([1, 3, 4， 5])
	```
	* 20.**str()**    函数将对象转化字符串
	* 21.max()    方法返回给定参数的最大值，参数可以为序列。max([1,3,7])  # 7
	* 22.min()    方法返回给定参数的最小值，参数可以为序列。
	* 23.sum()    方法对系列进行求和计算。sum([1,3,5])  # 9
	* 24.range()    函数可创建一个整数列表
	* 25.round(x)    方法返回浮点数x的四舍五入值。
	* 26.type()   返回对象类型。
* 34.filter、map、reduce的作用？
	* 1.filter是筛选出其中满足某个条件的那些数据..字面意思是过滤..比如挑出列表中所有奇数..
	* 2.map是用同样方法把所有数据都改成别的..字面意思是映射..比如把列表的每个数都换成其平方..
	* 3.reduce是用某种方法依次把所有数据丢进去最后得到一个结果..字面意思是化简..比如计算一个列表所有数的和的过程,就是维持一个部分和然后依次把每个数加进去..
	```
	>>> filter(lambda x:x&1,[0,1,2,3,4,5,6])
	[1, 3, 5]
	>>> map(lambda x:x*x,[0,1,2,3,4,5,6])
	[0, 1, 4, 9, 16, 25, 36]
	>>> reduce(lambda x,y:x+y,[0,1,2,3,4,5,6])
	21
	```
* 35.一行代码实现9\*9乘法表
	* print ('\n'.join([' '.join(['%s\*%s=%-2s' % (y,x,x*y) for y in range(1,x+1)]) for x in range(1,10)]))
* 36.如何安装第三方模块？以及用过哪些第三方模块？
	* 在Python中，安装第三方模块，是通过setuptools这个工具完成的。Python有两个封装了setuptools的包管理工具：easy_install和pip。目前官方推荐使用pip
	* 默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中：
	```
	>>> import sys
	>>> sys.path
	['', '/Library/Python/2.7/site-packages/pycrypto-2.6.1-py2.7-macosx-10.9-intel.e
		gg', '/Library/Python/2.7/site-packages/PIL-1.1.7-py2.7-macosx-10.9-intel.egg',
		...]
	```
* 37.至少列举8个常用模块都有那些？
	* 1.pip
	* 2.Django
	* 3.pyMysql
	* 4.Scrapy
	* 5.time
	* 6.datetime
	* 7.os  &  sys
	```
	>>> os.getcwd()    # 当前程序文件的绝对路径
	'D:\\python_temp\\study_test'
	```
	* 8.random
	* 9.re
	* 10.hashlib，有SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5 算法
	```
	hash = hashlib.sha1()  # 或者.md5()
	hash.update('admin')
	print(hash.hexdigest())
	```
	* 11.json
	* 12.traceback模块
	```
	mport traceback
	try:  	
	    1/0  	
	except Exception,e:  	
	    #print e	
	    traceback.print_exc(file=open('tb.txt','w+'))	
	else:	
	    print 'success'
	```
* 38.re的match和search区别？
	* 1.match()函数只检测re是不是在string的**开始位置匹配**(只有在**0位置匹配**成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回none。)，search()会扫描**整个string查找匹配**；
	```
	import re
	print(re.match(‘super‘, ‘superstition‘).span())  # （0,5）
	print(re.match(‘super‘, ‘insuperable‘))  # None
	```
	* 2.search()会扫描整个字符串并返回**第一个成功的匹配**：
	```
	import re
	print(re.search(‘super‘, ‘superstition‘).span()) #（0,5）
	print(re.search(‘super‘, ‘insuperable‘)) 
	# <_sre.SRE_Match object; span=(2, 7), match=‘super‘>
	```
	* 3.其中span函数定义如下，返回位置信息,即一个元组形式的起始索引和结束索引：
	span([group]): 
	返回(start(group), end(group))。
* 39.什么是正则的贪婪匹配（贪婪模式）？
	* 1.贪婪匹配（贪婪模式）：总是尝试匹配尽可能多的字符
	* 2.非贪婪匹配（非贪婪模式）：是尝试匹配尽可能少的字符
	```
	贪婪格式：xx.*xx
	非贪婪格式：xx.*?xx
	区别重点在：.* 和 .*？

	import re
	secret_code = ‘hadkfalifexxIxxfasdjifja134xxlovexx23345sdfxxyouxx8dfse‘
	b = re.findall(‘xx.*xx‘,secret_code)   # 贪婪匹配 
	print (b) # [‘xxIxxfasdjifja134xxlovexx23345sdfxxyouxx‘]
	c = re.findall(‘xx.*?xx‘,secret_code)  # 非贪婪匹配
	print(c) # [‘xxIxx‘, ‘xxlovexx‘, ‘xxyouxx‘]
	```
* 40.如何在函数中设置一个全局变量 ?
	* 在函数的内部，通过global声明，使在函数内部中设置一个全局变量，这个全局变量可以在任意的函数中进行调用！
* 41.logging模块的作用？以及应用场景？
	* 1.日志等级是从上到下依次升高的，即：DEBUG(10) < INFO(20) < WARNING(30) < ERROR(40) < CRITICAL(50)，而日志的信息量是依次减少的；
	```
	日志等级（level）	描述
	DEBUG	   最详细的日志信息，典型应用场景是 问题诊断
	INFO		信息详细程度仅次于DEBUG，通常只记录关键节点信息，
						用于确认一切都是按照我们预期的那样进行工作
	WARNING	 当某些不期望的事情发生时记录的信息（如，磁盘可用空间较低），
						但是此时应用程序还是正常运行的
	ERROR	   由于一个更严重的问题导致某些功能不能正常运行时记录的信息
	CRITICAL	当发生严重错误，导致应用程序不能继续运行时记录的信息
	```
	* 2.logging模块定义的模块级别的常用函数
	```
	logging.debug(msg, *args, **kwargs)		创建一条严重级别为DEBUG的日志记录
	logging.info(msg, *args, **kwargs)		 创建一条严重级别为INFO的日志记录
	logging.warning(msg, *args, **kwargs)	  创建一条严重级别为WARNING的日志记录
	logging.error(msg, *args, **kwargs)		创建一条严重级别为ERROR的日志记录
	logging.critical(msg, *args, **kwargs)	 创建一条严重级别为CRITICAL的日志记录
	logging.log(level, *args, **kwargs)		创建一条严重级别为level的日志记录
	**logging.basicConfig(**kwargs)**			  对root(日志器) logger进行一次性配置	

	import logging
	logging.debug("This is a debug log.")   
	#  logging.log(logging.DEBUG, "This is a debug log.")
	logging.info("This is a info log.")   
	#  logging.log(logging.INFO, "This is a info log.")
	logging.warning("This is a warning log.")   
	#  logging.log(logging.WARNING, "This is a warning log.")
	logging.error("This is a error log.")   
	#  logging.log(logging.ERROR, "This is a error log.")
	logging.critical("This is a critical log.")   
	#  logging.log(logging.CRITICAL, "This is a critical log.")
	# 结果
	WARNING:root:This is a warning log.   # 日志级别:日志器名称:日志内容
	ERROR:root:This is a error log.   	# 日志器设置的日志格式默认是BASIC_FORMAT
	CRITICAL:root:This is a critical log. #"%(levelname)s:%(name)s:%(message)s"
	
	为什么前面两条日志没有被打印出来？
	因为logging模块提供的日志记录函数所使用的日志器设置的日志级别是WARNING，因此只有WARNING级别
	的日志记录以及大于它的ERROR和CRITICAL级别的日志记录被输出了，而小于它的DEBUG和INFO级别的
	日志记录被丢弃了。

	logging.warning('name:%s msg:%s','BeginMan','Hi')  			 #方式一
	logging.warning('name:%s msg:%s' %('BeginMan','Hi'))            #方式二
	logging.warning('name:{0} msg:{1}'.format('BeginMan','Hi'))     #方式三

	```
	* 3.打印日志到文件中
	```	
	import logging
	# 进行一次性配置，程序运行时执行一次
	logging.basicConfig(level=logging.INFO,  
	        format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s',  
	        # datefmt='%a, %d %b %Y %H:%M:%S',   # datefmt：时间的格式化
			# 一, 02 10 2017 16:47:19 test.py[line:17] DEBUG debug message
	        filename='test.log',  #  当前文件目录或者指定目录'/home/python/Desktop/log/test.log'  
	        filemode='a')  	   #  a为追加模式，w为新建并打开模式

	logging.debug('debug message')
	logging.info('info message')
	logging.warning('warning message')
	logging.critical('citical message')
	logging.error('error message')
	# 结果 cat test.log（日期，当前程序文件名，行数，日志级别，日志信息）
	2017-10-21 03:25:51,509 test.py[line:14] INFO This is info message
	2017-10-21 03:25:51,510 test.py[line:15] WARNING This is warning message
	！！！level：只用大于等于日志级别的日志才会被处理 
	！！！format：输出日志的格式 
	# 日志格式
		--------------------------------------------------
	 %(asctime)s       年-月-日 时-分-秒,毫秒 2018-04-26 20:10:43,745
	 %(filename)s      文件名，不含目录
	 %(pathname)s      目录名，完整路径
	 %(funcName)s      函数名
	 %(levelname)s     级别名
	 %(lineno)d        行号
	 %(module)s        模块名
	 %(message)s       消息体
	 %(name)s          日志器名
	 %(process)d       进程id
	 %(processName)s   进程名
	 %(thread)d        线程id
	 %(threadName)s    线程名
	```
* 42.闭包：
	* 1.外函数：函数A的内部定义了函数B，那么函数A就叫做外函数
	* 2.内函数：函数B就叫做内函数
	* 在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。
	```
	def outer(a):  		# 外函数 
    	b = 10
		print 'haha'
    	def inner():		 # 内函数 
        	print(a+b)	   # 调用外函数的形参a和外函数的局部变量b 
    	return inner		 # 返回内函数 

	if __name__ == ‘__main__‘:
		demo = outer(5)    # 'haha' ，此时闭包外函数调用并执行，变量demo指向内函数
	    demo() 			# 15
	```
	* 3.一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个**临时变量绑定给了内部函数**，然后自己再结束。
* 43.面向切面编程AOP（即装饰器），一般和闭包联合使用：
	* 1.装饰器的作用就是为已经存在的对象添加额外的功能。@classmethod和@staticmethod就是装饰器使用的明显方法；
	* 2.定义一个函数def test():...；此时用@test可以将此函数功能用到其他任何函数上优先执行，俗称**语法糖**，可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重复使用。
	* 3.内置的装饰器有三个，分别是staticmethod、classmethod和property，作用分别是把类中定义的实例方法变成静态方法、类方法和类属性。
* 44.Python中不需要重载，原因：
	* 重载的目的：1. 可变参数类型。2. 可变参数个数。
	* 对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。
	对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。
	故鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。
* 45.新式类和旧式类（经典类）
	* 1.区别：简单的说，新式类是在创建的时候继承内置object对象（或者是从内置类型，如list,dict等），而经典类是直接声明的，没有继承object对象。
	```
	#新式类
	class C(object):
	    pass
	#经典类
	class B:
	    pass
	```
	* 2.Python3里的类全部都是新式类（继承object的类）。这里有一个MRO(Method Resolution Order，**方法解析顺序**)问题可以了解下(**旧式类是深度优先，新式类是广度优先**)
	```
		  	A(fool1)			(父级)
	B(fool2)		C(fool1)	(子级)
		 	 D(pass)			 (子子级)
	
	class A():
	    def foo1(self):
	        print "A"
	class B(A):
	    def foo2(self):
	        pass
	class C(A):
	    def foo1(self):
	        print "C"
	class D(B, C):
	    pass
	
	d = D()
	d.foo1()	# 结果：A ，不是 C

	d = D()，当调用d.foo1()的时候会发生什么事呢？
	在经典对象模型中，方法和属性的查找链是按照从**左到右，深度优先**的方式进行查找。所以当D的实例d
	要使用实例方法fool1时，它的查找顺序为:D->B->A->C->A，这样做就会忽略类C的定义fool1，而先找到的基类A的
	方法fool1，这是一个bug，这个问题在新式类中得到修复，新的对象模型采用的是**从左到右，广度优先**的方式
	进行查找，所以查找顺序为D->B->C->A，可以正确的返回类C的方法fool1。
	```
	* 3.这个顺序的实现是通过**新式类中**特殊的只读属性**类名.\_ \_mro\_ _**，类型是一个**元组**，保存着**解析顺序信息**。只能**通过类来使用**，**不能通过实例调用**。
	```
	1.只有新式类中（继承自object）才有此属性，解析顺序按照从左往右、广度优先的顺序。
	D.__mro__	(python3中D.mro()即可)
	(<class '__main__.D'>,<class '__main__.B'>,<class '__main__.C'>,<class '__main__.A'>,<type 'object'>)
	
	2.解析顺序还和继承时，括号中写的父类顺序有关：
	class D(C, B):  则
	(<class '__main__.D'>,<class '__main__.C'>,<class '__main__.B'>,<class '__main__.A'>,<type 'object'>)
	```
* 46.\_ \_new\_ \_静态方法和\_ \_init\_ \_实例方法的区别？
	* 1.新式类都有一个\_ \_new\_ \_的静态方法,\_ \_new\_ \_的静态方法是创建一个新的，没有经过初始化的实例对象，然后返回值是类D的实例d，在确认d是D的实例后，python再调用D.__init__(d, \*args, **kargs)来初始化实例d。
	* 2.`__new__`是一个静态方法,而`__init__`是一个实例方法.
	`__new__`方法会返回一个创建的实例,而`__init__`什么都不返回.
	只有在`__new__`返回一个cls的实例对象时后面的`__init__`才能被调用.
	当创建一个新实例时调用`__new__`,初始化一个实例时用`__init__`
* 47.单例模式(这个绝对常考，绝对要记住1~2个方法)
	* 单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。
	通过单例模式可以保证系统中**一个类只有一个实例而且该实例易于外界访问**，从而方便对实例个数的控制并节约系统资源。如果希望在系统中**某个类的对象只能存在一个**，单例模式是最好的解决方案。
	* 1.`__new__`()静态方法在`__init__`()初始化实例方法**之前被调用**，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。单例模式是**指创建唯一对象**，单例模式设计的类只能实例。
	* 2.单例模式的实现：使用 `__new__`静态方法，使用装饰器（decorator），使用模块；
	* 3.使用 `__new__`静态方法
	```
	class Singleton(object):
	    	_instance = None
	    	def __new__(cls, *args, **kw):
		        if not cls._instance:
		            cls._instance = super(Singleton, cls).__new__(cls, *args, **kw)  
		        return cls._instance  
 
	class MyClass(Singleton):  
	    	a = 1
	在上面的代码中，我们将类的实例和一个类变量 _instance 关联起来，如果 cls._instance 为 None 则创建
	实例，否则直接返回已经存在的实例cls._instance，创建的多个实例对象指向同一实例值和id地址。
	# 结果
	>>> one = MyClass()
	>>> two = MyClass()
	>>> one == two
	True
	>>> one is two
	True
	>>> id(one), id(two)
	(4303862608, 4303862608)
	# 若：
	class MyClass2(Singleton):
			pass
	>>> one = MyClass2()
	>>> two = MyClass2()
	>>> id(one), id(two)
	(4444666666, 4444666666)
	```
	* 4.使用装饰器（decorator）
	装饰器（decorator）可以**动态地修改一个类或函数的功能**。这里，我们也可以使用装饰器来装饰某个类，使其只能生成一个实例
	```
	def singleton(cls):
		    instances = {}
		    def getinstance(*args, **kw):
		        if cls not in instances:
		            instances[cls] = cls(*args, **kw)
		        return instances[cls]
		    return getinstance
 
	@singleton		# 在创建对象时先执行装饰器的功能，再执行下面的类或函数本身的功能
	class MyClass(object):
	    	a = 1
	我们定义了一个装饰器 singleton，它返回了一个内部函数 getinstance，该函数会判断某个类是否在
	字典 instances 中，如果不存在，则会将 cls 作为 key，cls(*args, **kw) 作为 value 存到 instances 中，
	否则，直接返回字典instances[cls]对应的键的值。此值到object中用`__new__`方法创建对象。
	由于第一个对象存在后，其他再创建的对象都返回第一个对象的值，故new方法每次都是第一次的那个实例对象，即单例对象
	```
	* 5.使用模块（**Python 的模块就是天然的单例模式**）
	```
	# mysingleton.py
	class My_Singleton(object):
		    def foo(self):
		        pass
	 my_singleton = My_Singleton()

	将上面的代码保存在文件 mysingleton.py 中，然后这样使用：
	from mysingleton import my_singleton   
	# 导入在模块中已创建好的一个对象，此对象在原模块中已创建且只有一个，在新文件中无法创建更多的对象，故也是单例对象。
	my_singleton.foo()
	```
* 48.sys和os模块的作用？
	* 1.sys模块：主要是用于提供对python解释器相关的操作(即程序运行环境相关的操作)
	```
	常用功能
	1.sys.argv[]	 #命令行参数List列表（即位置参数），第一个元素是程序本身路径或程序本身文件名
	# test.py
	import sys
	a=sys.argv[0];
	print (a)
	# 结果 python test.py
	在Windows上运行时，得到的结果会打印本身文件路径：D:\python\demo\test.py
	在Linux上是文件名：test.py
	# 结果 python test.py  1 2 3 4 5
	['test.py', ‘1‘, ‘2‘, ‘3‘, ‘4‘, ‘5‘]
	
	2.sys.path 	  #返回模块的搜索路径，可通过添加自定义路径，来添加自定义模块
		['', 'C:\\windows\\system32\\python27.zip', 'D:\\Python\\DLLs', 'D:\\Python\\lib', 
		'D:\\Python\\lib\\plat-win', 'D:\\Python\\lib\\lib-tk', 
		'D:\\Python', 'D:\\Python\\lib\\site-packages', 'D:\\Python\\lib\\site-packages\\win32', 
		'D:\\Python\\lib\\site-packages\\win32\\lib', 'D:\\Python\\lib\\site-packages\\Pythonwin']
	3.sys.exit(n)	#退出程序，正常退出时exit(0)，此时echo $?值为0
	4.sys.version	#获取Python解释程序的版本信息
		'2.7.10 (default, May 23 2015, 09:44:00) [MSC v.1500 64 bit (AMD64)]'
	5.sys.platform	#返回操作系统平台名称
		linux平台返回linux，windows平台返回win32，MAC返回darwin
	```
	* 2.os模块：是Python标准库中的一个用于访问操作系统功能的模块，使用OS模块中提供的接口，可以实现跨平台访问
	```
	1.os.getcwd() 			 获取当前工作目录，即当前python脚本工作的目录路径
		'D:\python_temp\study_test'
	2.os.chdir(dirname)   	 改变当前脚本工作目录；相当于shell下lcd
	3.os.makedirs(‘dir1/dir2‘) 可生成多层递归目录,没有的目录则创建
	4.os.removedirs(‘dirname1‘) 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推
	5.os.mkdir(‘dirname‘) 	  生成单级目录；相当于shell中mkdir dirname
	6.os.rmdir(‘dirname‘) 	  删除单级空目录，若目录不为空则无法删除，报错
	7.os.listdir(‘dirname‘)	 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印
		['.idea', 'test1.py']
	8.os.remove() 			  删除一个文件
	9.os.rename(oldname,new)	重命名文件/目录
	10.os.sep 				  操作系统特定的路径分隔符，win下为'\',Linux下为'/'
	11.os.linesep 			  当前平台使用的行终止符,即换行符，win下为'\r\n',Linux下为'\n'
	12.os.name 				 字符串指示当前使用平台。win->‘nt‘; Linux->‘posix‘
	13.os.path.exists(path) 	如果path存在，返回True；如果path不存在，返回False
	```
* 49.如何生成一个随机数？
	* 1.随机浮点数：random.random( ):返回0到1之间的浮点数
	random.uniform(a,b):返回指定范围内的浮点数。
	* 2.随机整数：random.randint(a,b)：返回随机整数x,a<=x<=b
	random.randrange(start,stop,[,step])：返回一个范围在(start,stop,step)之间的随机整数，不包括结束值。
	* 3.random.shuffle(args) # 使有序变为无序,直接对args可迭代对象（元组除外）无序化
	```
	data = range(10)
	print(data)  			# 打印有序的列表 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
	random.shuffle(data) 	# 使有序变为无序 
	print(data) 			 # 打印无序的列表 [4, 2, 5, 1, 6, 3, 9, 8, 0, 7]
	```
* 50.如何使用python删除一个文件？
	* 1.os.remove(path) **删除path指定的文件**. 如果path是一个目录， 抛出 OSError错误。如果要删除目录，请使用rmdir().
	```
	import os
	my_file = ‘D:/text.txt‘ # 文件路径
	if os.path.exists(my_file): # 如果文件存在
		    #删除文件，可使用以下两种方法。
		    os.remove(my_file) # 则删除
		    #os.unlink(my_file)
			#remove() 同 unlink() 的功能是一样的 
	else:
	    	print(‘no such file:%s‘%my_file)

	```
	* 2.os.removedirs(path)**递归地删除目录**。如果子目录被成功删除， removedirs() 将会删除父目录；但子目录没有成功删除，将抛出错误。例如， os.removedirs(“foo/bar/baz”) 将首先删除baz目录，然后再删除bar和 foo。
 	* 3.os.rmdir(path)**删除目录path指定的目录**，要求path必须是个空目录，否则抛出OSError错误；若目录不为空或者多级，需要用removedirs()。
* 51.谈谈对**面向对象**的理解？在python当中**一切皆对象**,每产生一个对象会对应三个属性:**id、类型type和数值** 。
	* 面向对象的程序设计的核心是对象，面向过程的程序设计的核心是过程（流水线式思维）。
	* 面向过程即解决问题的步骤，面向过程的设计就好比精心设计好一条流水线，考虑周全什么时候处理什么东西。
	* 面向对象即将数据属性和方法属性集合在一起，简单说即是将程序模块化，对象化。
	* 三个基本特征：
	* 1.封装：把具体事物的特性属性和通过这些属性来实现一些动作的具体方法放到一个类里面，这就是封装；
	* 2.继承：就是父类的相关的属性和方法，可以被子类重复使用，子类不必再在自己的类里面重新定义一回，父类里有直接拿过来用就可以了。而对于自己类里面需要用到的新的属性和方法，子类就可以自己来扩展。
			Python面向对象中的继承有什么特点？
			1.建造系统中的类，**避免重复操作和重复写代码**。
			2.新建类经常是基于已经存在的类，这样就可以**提升代码的复用程度**
	* 3.多态：一般是指在父类中定义的方法被子类继承后，可以表现出不同的行为。这使得同一个方法在父类及其各个子类中具有不同的语义。
			多态包含了重载和重写：
			重载：就是类里面相同方法名，不同形参的情况，可以是形参类型不同或者形参个数不同，或者形参顺序不同，
			由于python对变量类型和缺省参数的不限制，使python中一般不用重载。
			重写：就是把子类从父亲类里继承下来的方法重新写一遍使父类里相同的方法被覆盖，此子类使用覆盖后的新属性或方法，
			父类中属性或方法存在但不被重写子类用，其他子类仍然可以通过super（）方法来调用父类的属性或方法。
* 52.面向对象中super的作用？
	* 1.super() 是用于调用父类(超类)的一个方法。当我们调用 super() 的时候，实际上是实例化了一个 super 类。没有看错， super 是个类，class super(object)。
	* 2.super(type[, object-or-type]) type -- 类名，object-or-type --对象或类，一般是 self，极少是cls。
	* 3.Python3.x 和 Python2.x 的一个区别是: Python3可以使用直接使用 **super().xxx方法名() 代替 super(Class类名, self).xxx 方法名()**：
	```
	Python3.x 实例：
	class A:					 # 在Python3中，默认是新式类，即A默认继承自object
		def __init__(self):
			pass
	super().__init__()			# A.__init__(self)即：父类.方法（self）也可以调用父类方法，但与super内部处理机制大大不同

	Python2.x 实例：
	class A（object）:			# 在Python2中，默认是旧式类，需要加上继承自object
		def __init__(self):
			pass
	super(A, self).__init__()
	```
	* 4.在super机制里可以保证公共父类仅被执行一次，至于执行的顺序，是按照MRO（Method Resolution Order）：方法解析顺序 进行。
	```
		class A(object):
		    def __init__(self):
		        self.n = 2		
		    def add(self, m):
		        # 第四步
		        # 来自 D.add 中的 super
		        # self == d, self.n == d.n == 5
		        print('self is {0} @A.add'.format(self))
		        self.n += m
		        # d.n == 7

		class B(A):
		    def __init__(self):
		        self.n = 3		
		    def add(self, m):
		        # 第二步
		        # 来自 D.add 中的 super
		        # self == d, self.n == d.n == 5
		        print('self is {0} @B.add'.format(self))
		        # 等价于 suepr(B, self).add(m)
		        # self 的 MRO 是 [D, B, C, A, object]
		        # 从 B 之后的 [C, A, object] 中查找 add 方法
		        super().add(m)
		
		        # 第六步
		        # d.n = 11
		        self.n += 3
		        # d.n = 14
		
		class C(A):
		    def __init__(self):
		        self.n = 4		
		    def add(self, m):
		        # 第三步
		        # 来自 B.add 中的 super
		        # self == d, self.n == d.n == 5
		        print('self is {0} @C.add'.format(self))
		        # 等价于 suepr(C, self).add(m)
		        # self 的 MRO 是 [D, B, C, A, object]
		        # 从 C 之后的 [A, object] 中查找 add 方法
		        super().add(m)
		
		        # 第五步
		        # d.n = 7
		        self.n += 4
		        # d.n = 11
			
		class D(B, C):
		    def __init__(self):
		        self.n = 5		
		    def add(self, m):
		        # 第一步
		        print('self is {0} @D.add'.format(self))
		        # 等价于 super(D, self).add(m)
		        # self 的 MRO 是 [D, B, C, A, object]
		        # 从 D 之后的 [B, C, A, object] 中查找 add 方法
		        super().add(m)
		
		        # 第七步
		        # d.n = 14
		        self.n += 5
		        # self.n = 19		
		d = D()
		d.add(2)
		print(d.n)

	#	结果
	self is <__main__.D object at 0x10ce10e48> @D.add
	self is <__main__.D object at 0x10ce10e48> @B.add
	self is <__main__.D object at 0x10ce10e48> @C.add
	self is <__main__.D object at 0x10ce10e48> @A.add
	19
	# D 的 MRO 是: [D, B, C, A, object]

	例子：有个 MRO:[A, B, C, D, E, object]
	super(C, A).__init__()
	super 只会从 C 之后从左往右查找，即: 只会在 D 或 E 或 object 中查找 __init__方法。
	```
* 53.functools模块介绍
	* 1.指那些作用于函数或者返回其他函数的函数。通常情况下，只要是可以被当做函数调用的对象就是这个模块的目标。可以生成一个固定参数的新函数。
	```
	import functools
	foo = functools.partial(int, base=8)  # 将int函数生成一个新的foo函数，int函数的进制参数固定为8
	foo(‘11111‘)  # print 4681
	# 等同
	def int2(x, base=8):
  		return int(x, base)
	>>> int2('1000000')
	262144
	```
	* 2.functools.partial就是帮助我们创建一个偏函数的，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。
* 54.如何判断是函数还是方法？
	* 函数是封装了一些独立的功能，可以直接调用，python内置了许多函数，同时可以自建函数来使用。
	* 方法和函数类似，同样封装了独立的功能，但是方法是需要通过对象来调用的，表示针对这个对象要做的操作，使用时采用**点方法**调用。
* 55.列举面向对象中的特殊成员以及应用场景？(即类的特殊方法)
	* 1.`__doc__`  描述类的信息
	```
	class Foo(object):  
		    # 单引号和双引号都可以  
		    """这里描述类的信息，哈哈"""  
		  
		    def func(self):  
		        pass  
  
	print(Foo.__doc__)  	# 这里描述类的信息，哈哈
	```
	* 2.`__dict__` 查看类或对象中的所有属性
	```
	class Foo(object):  
		    def __init__(self, name, age):  
		        self.name = name  
		        self.age = age  
  
	foo = Foo("UserPython", 17)  
	  
	print(Foo.__dict__) # 字典，打印类里的所有属性和对应的值，以及实例方法名和id地址，不包括实例方法的属性  
	print(foo.__dict__) # 字典，打印所有实例方法的属性和对应的值，不包括类属性和实例方法的id地址
	#	结果
	{‘__weakref__‘: <attribute ‘__weakref__‘ of ‘Foo‘ objects>, ‘__init__‘: <function Foo.__init__ at 0x0000000000BB0730>, 
	‘__dict__‘: <attribute ‘__dict__‘ of ‘Foo‘ objects>, ‘__module__‘: ‘__main__‘, ‘__doc__‘: None}
	{‘name‘: ‘UserPython‘, ‘age‘: 17}
	```
	* 3.`__str__` 如果一个类中定义了`__str__`方法，那么在打印对象时，默认输出该方法的返回值
	```
	class Foo(object):  
		    def __init__(self, name, age):  
		        self.name = name  
		        self.age = age  		  
		    def __str__(self):  
		        return "<obj：%s>" % self.name   
	foo = Foo("UserPython", 17)  	  
	print(foo) 	# >>>	<obj：UserPython>
	```
	* 4.`__new__`方法
	* 5.`__init__`方法
	* 6.`__del__`方法
	```
	1.在程序执行完了之后会自动执行的内容
	class Foo(object):
		     def __init__(self,x):
		         self.x=x
		     def __del__(self):
		         print('执行__del__')
		         '''一般用来做一些关于对象执行完了之后剩下的垃圾的清理操作'''
	f=Foo(10)
	print('执行完了')
	# 输出结果：先执行最后的print，没有代码了执行__del__函数(即程序执行完后关闭程序回收f对象内存时执行)
	执行完了
	执行__del__

	2.删除对象后立即执行的内容
	class Foo(object):
		     def __init__(self,x):
		         self.x=x
		     def __del__(self):
		         print('执行__del__')
		         '''做一些关于对象的清理操作'''
	 f=Foo(10)
	 del f     			#删除的时候也会执行del内容
	 print('执行完了')
	# 输出结果：删除了f对象后执行了__del__，后才执行最后的print
	执行__del__
	执行完了
	```
* 56.反射（用户交互）：通过字符串的形式操作对象相关的属性。
	* isinstance(obj,cls)和issubclass(sub,super)
	```
	1.isinstance(obj,cls)检查是否obj是否是类 cls 的对象，如果是返回True
	class Foo(object):
	    pass
	obj = Foo()
	print(isinstance(obj, Foo))		# True

	2.issubclass(sub, super)检查sub类是否是 super 类的派生类(子类)，如果是返回True
	class Foo(object):
	    pass 
	class Bar(Foo):
	    pass
	issubclass(Bar, Foo)			   # True
	```
	* 1.hasattr(obj,name_str) 判断一个对象obj中(或者类cls中)是否有对应的name_str字符串属性或者方法，返回布尔值True 或者False
	```
	class Teacher:
		     school='jialidun'
		     def __init__(self,name,age):
		         self.name=name
		         self.age=age
		     def teach(self):
		         print('%s is teacher.' %self.name)

	t=Teacher('bob',18)
	print(hasattr(Teacher,'name'))  	#False，判断类中属性
	print(hasattr(Teacher,'school'))    #True，判断类中属性
	print(hasattr(Teacher,'teach'))     #True，判断类中方法
	print(hasattr(t,'name'))  		  #True，判断类中属性
	print(hasattr(t,'school'))    	  #True，判断类中属性
	print(hasattr(t,'teach'))     	  #True，判断类中方法
	```
	* 2.getattr(obj,name_str) 根据字符串去获取obj对象里（类cls里）的对应属性的值或者方法的内存id地址。
	```
	print(getattr(Teacher,'school'))	# 获取到类属性的值：'jialidun'，类不能获取实例属性的值，实例对象可以获取类属性的值
	print(getattr(Teacher,'name'))	  # 返回错误，程序中断
	print(getattr(t,'name'))			# bob
	print(getattr(t,'school'))		  # 'jialidun'

	print(getattr(Teacher,'teach'))	 # 获取到类方法的id地址，此类方法未实例化没有地址：<unbound method Teacher.teach>
	print(getattr(t,'teach'))   		# 类已经实例化，所有实例方法有id地址
	# <bound method Teacher.teach of <__main__.Teacher instance at 0x000000000268BF08>>
	print(getattr(Teacher,'haha','junge'))	# 'junge' :获取不到返回默认'junge'，如果不指定那么抛出异常错误
	```
	* 3.setattr(d,name_str,[value]) 给对象obj（或类cls）的属性重新定义，若不存在，先创建再赋值
	```
	setattr(Teacher,'sex','male')    #设定Teacher类的属性sex='male'
	setattr(t,'sex','female')    	#设定对象t的实例属性sex='female'
	print(Teacher.__dict__)
	# {'__module__': '__main__', 'school': 'jialidun', 'sex': 'male', 
	'teach': <function teach at 0x0000000002559C88>, '__doc__': None, 
	'__init__': <function __init__ at 0x0000000002559C18>}
	
	print(t.__dict__)
	# {'age': 18, 'name': 'bob', 'sex': 'female'}
	```
	* 4.通过字符串的方式删除一个属性：
	```
	delattr(Teacher,'sex')
	delattr(t,'sex')
	```
* 57.异常处理写法以及如何主动跑出异常?
	* 1.异常处理写法:try ....except...else...finally...
	```	
	try:
			"""执行语句"""
	except: #异常类型
			"""触发异常后执行的语句"""
	else:
			"""没有异常后执行的语句"""
	finally:
			"""有无异常总是执行的语句"""
	
	# 主动抛出异常
	raise  ValueError #异常类实例
	常见的异常类型：
	ValueError		 传入无效的参数，传入参数错误
	IOError			输入/输出操作失败
	OSError			操作系统错误
	ImportError		导入模块/对象失败
	NameError		  未声明/未初始化对象 (没有属性)，使用一个还未赋予对象的变量
	SyntaxError		Python 语法错误
	TypeError		  对类型无效的操作
	TabError		   Tab 和空格混用
	AttributeError	 访问一个对象没有的属性
	IndentationError   缩进错误，代码没有正确的对齐
	IndexError		 下标索引超出序列边界
	KeyError		   字典里的键不存在
	```
	* 2.当Python程序发生异常时我们需要捕获处理它，否则**程序会终止执行并退出当前程序**。
* 58.json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？
	* 1.字典、列表、字符串、数字、布尔值、None、自定义class类
	* 2.支持datetime类型，datetime.datetime.now():(2018, 10, 4, 0, 21, 1, 653000)
	```
	import json
	import datetime 
	class MyEncoder(json.JSONEncoder):   
			def default(self, obj):  # obj是数据类型,即datetime的实例化对象       
				if isinstance(obj, datetime.datetime)           
					return obj.strftime('%Y-%m-%d %H:%M:%S')       
				else:           
					return super(MyEncoder, self).default(obj)
 	d = { ‘name‘:‘alex‘,‘data‘:datetime.datetime.now()}
	print(json.dumps(d,cls=MyEncoder))
	# '{"name": "alex", "data": "2018-05-20 19:52:05"}'
	```
	* 3.json序列化时遇到中文会默认转换成unicode，如何让他保留中文形式
	```
	import json
	a=json.dumps({"ddf":"你好"},ensure_ascii=False)  # dumps默认采用ascii编码，取消后用unicode编码
	# a=json.dumps({"ddf":"你好"},ensure_ascii=False, encoding='utf-8')
	print(a)		 # '{"ddf": "你好"}'
	```
* 59.简述yield和yield from关键字。
	```	
	yield：生成器函数关键字
	yield from obj：相当于 
	for i in obj： 
		yield i
	例子：
	def a():
	   yield 1
	def b():
	   yield from a()
	```
* 60.提高python运行效率的方法：
	* 1.使用生成器，因为可以节约大量内存
	* 2.循环代码优化，避免过多重复代码的执行
	* 3.核心模块用Cpython，提高效率
	* 4.尽量使用多进程、多线程、协程等方式
	* 5.多个if elif条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率

## 二、python高级特性
* 1.Python中的作用域：
	* 当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）
* 2.GIL线程全局解释器锁：
	* 1.线程全局解释器锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是**一个核只能在同一时间运行一个线程**.对于IO密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。
	* 2.GIL并不是python的特性，它是在实现python解析器(Cpython)时所引入的一个概念。
	* 3.解决办法就是：多 + 进程和协程(协程也只是单CPU,但是能减小切换代价提升性能).
* 3.进程：
	* 程序：编写完的代码称为程序。
	* 进程：又称重量级进程，正在执行中的程序称为进程。
	* 1.进程的执行会占用内存等资源。多个进程同时执行时，每个进程的执行都需要由操作系统按一定的算法（RR调度、优先数调度算法等）分配内存空间。
	* 2.四核CPU：一个CPU有4个计算处理核心，CPU运作时4个处理核心各自处理各自任务，互不干扰。现在市面上一般是一核双线程，即四核8线程，八核16线程。
	* 3.并行：在多核系统中，每个cpu执行多个进程，可以理解为cpu的数大于进程数，所有进程同时进行。
	并发：在操作系统中同时执行多个进程，可以理解为cpu的数小于进程数，有些进程会没有机会执行，即会有任务轮空到下一轮。
	区别：并行指两个或多个程序在同一时刻执行；并发指两个或多个程序在同一时间间隔内发生，可以理解为在表面上看是同时进行，但在同一时刻只有少于程序的总数的程序在执行，计算机利用自己的调度算法让这些程序分时的交叉执行，由于交换的时间非常短暂，宏观上就像是在同时进行一样。
	* 4.os.fork（）操作系统会将当前的进程复制一份，原来的进程称为父进程，新创建的进程称为子进程。**注意：这个os.fork()方法只有在unix系统中才会有，在window下没有**。
		* os.getpid（）:获取进程的进程号。
		* os.getppid（）：获取父进程的进程号。
		* os.kill(编号，9)：根据进程编号杀死对应的进程，9表示强制杀死
		```
		from multiprocessing import Process
		import time	
		def test(a):
		    for i in range(a):
		        print("子进程...")
		        time.sleep(1)		
		p = Process(target=test,args=(5,))
		p.start()
		p.join(2)
		print("父进程...")

		这里的p相当于Process类的一个实例对象，每实例化一个对象就是创建一个子进程。	
		target = test ：子进程所执行的任务，就是test这个函数
		args = (5,)  :给进程函数传参，这里需要用元组的方式进行传参
		p.start（） ：执行子进程，只用调用start（）方法，子进才会执行
		p.join(n)  ：让主进程等待n秒钟
		p.join()  ：没有参数，则让主进程一直等待至全部子进程结束

		Process常用的方法：
		start（）：启动进程
		is_alive() ：判断进程是否还在执行，返回True 或 False	
		join(n) : 主进程等待子进程，n为等待的时间（秒），必须在close或terminate之后使用。		
		run() :在调用start方法时会自动调用run()方法，可以创建Process类的子类来重写run()方法的方式创建进程		
		terminate（）：不管子进程是否结束，强制使子进程立即终止
		daemon = True :设置守护主进程, 主进程退出后子进程直接销毁了
		```
	* 5.利用multiprocessing模块Pool创建进程池
	```
	from multiprocessing import Pool
	import time
	import os
	
	def work(i):
	    time.sleep(1)
	    print(i,"当前程序的pid=",os.getpid())
	def work1(i):
	    time.sleep(1)
	    print(i,"当前程序的pid=",os.getpid())
	
	def work2(i):
	    time.sleep(1)
	    print(i,"当前程序的pid=",os.getpid())
	# 创建进程池
	pool = Pool(2)
	# 使进程开始执行
	pool.apply_async(work,(1,))
	pool.apply_async(work1,(2,))
	pool.apply_async(work2,(3,))
	pool.apply(work1,(4,))
	pool.apply(work2,(5,))
	pool.apply(work1,(6,))
	pool.apply(work2,(7,))
	# 关闭进程池
	pool.close()
	# 让主进程等待子进程
	pool.join()

	pool = Pool（2）
	创建一个进程池，进程池中同时开两个进程，如果任务多于进程数时,进程会逐个执行任务，当一个进程完成任务后，
	接着执行待完成的任务，直到所有任务全部完成。
	pool.apply_async(func,args) 
	非堵塞式，异步执行，即多个子进程一起进行无先后顺序。func调用的为任务，args：为func传参，参数以元组的方式传递。	
	pool.apply(func,args) 
	堵塞式执行。进程会等待上一个进程结束才会进行，主进程也堵塞于此。传参同上。	
	pool.close() ：关闭进程池，停止向进程池中添加任务	
	pool.join()  ：使主进程等待。必须在close（）或者terninate（）后面使用。
	```
* 4.线程：又称轻量级进程。
	* 1.一个进程内的所有线程共享全局变量，每个线程内的局部变量各自独有不共享，所以线程非安全：即对一个全局变量，所有线程都可以随意更改。
	```
	import threading
	import time
	def action(arg):
	    time.sleep(1)
	    print 'the arg is:%s\r' %arg	
	for i in xrange(4):
	    t =threading.Thread(target=action,args=(i,))
	    t.start()
		t.join()	
	print 'main thread end!'

	Thread(target=None, name=None, args=(), kwargs={}) 
	target: 要执行的方法；name: 线程名，可自定义，也可不写，则用默认Thead-（num数字）；args/kwargs: 要传入方法的参数。
	start(): 启动线程。 
	join([timeout]): 阻塞当前主线程，直到调用此方法的线程终止或到达指定的timeout（可选参数）主线程才终止。
	```
	* 2.当一个进程启动之后，会默认产生一个主线程，因为线程是程序执行流的最小单元，当设置多线程时，主线程会创建多个子线程，在python中，默认情况下（其实就是setDaemon(False)），主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束。
	* 3.当我们使用setDaemon(True)方法，即t.setDaemon(True)，**设置子线程为守护线程**时，主线程一旦执行结束，则全部线程全部被终止执行，可能出现的情况就是，子线程的任务还没有完全执行结束，就被迫停止。
	* 4.join所完成的工作就是线程同步，即主线程任务结束之后，进入阻塞状态，一直等待其他的子线程执行结束之后，主线程在终止。
	* 5.join有一个timeout参数：
		* 1.当设置守护线程时，含义是主线程对于子线程等待timeout的时间将会杀死该子线程，最后退出程序。所以说，如果有10个子线程，全部的等待时间就是每个timeout的累加和。简单的来说，就是给每个子线程一个timeout的时间，让他去执行，时间一到，不管任务有没有完成，直接杀死。
		* 2.没有设置守护线程时，主线程将会等待timeout的累加和这样的一段时间，时间一到，主线程结束，但是并没有杀死子线程，子线程依然可以继续执行，直到子线程全部结束，程序退出。
	* 6.线程之间随机调度，为了多个线程同时操作一个内存中的资源时不产生混乱，我们使用锁。
	```
	import threading
	lock = threading.Lock() # Lock对象
	lock.acquire()		  # 加锁
	lock.release()		  # 释放锁

	threading.current_thread()  # 获取当前线程名和引用地址（Thead-2  started 1432...）
	```
* **主进程和主线程都不会等待子进程和子线程；主进程结束子进程也结束，主线程结束子线程不结束；加了join后主进程和主线程会都不结束，等待后再结束。**
* 5.协程：
	* 1.协程，又称微线程，是一种用户态的**轻量级线程**。
	* 2.简单点说：协程是进程和线程的升级版，进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间，而协程就是用户自己控制切换的时机，不再需要陷入系统的内核态。

## 三、操作系统
* 1.**select,poll和epoll都是 I/O 多路复用的机制，I/O 多路复用，也称为 I/O 多路转接。**：
	* 其实**所有的I/O都是轮询的方法**,只不过实现的层面不同罢了.
	* 1.select：select/poll一般只能处理几千的并发连接。
	```
	基本上select有3个缺点:
	1.连接数受限，单个进程能够监视的文件描述符的数量存在最大限制，通常是1024，文件描述符数量越多，性能越差。
	2.效率问题，查找配对速度慢，应用程序需要遍历整个数组才能发现哪些句柄发生了事件；
	3.数据由内核拷贝到用户态，select需要复制大量的句柄数据结构，用户空间内存产生巨大的开销。
	```
	* 2.poll改善了第一个缺点，poll使用链表保存文件描述符，因此没有了监视文件数量的限制。其他缺点依然存在
	* 3.epoll改了三个缺点。
	* 4.nginx中使用了epoll，对于ngnix会有很多链接进来， epoll会把他们都监视起来，然后像拨开关一样，谁有数据就拨向谁，然后调用相应的代码处理。
	* 5.epoll建立在大并发链接情况下，即**多路网络连接复用一个IO线程**；多路复用，一条路可以很多人同时走的路；Multiplexing：one to many。
	```
	一个epoll场景：一个酒吧服务员（一个线程），前面趴了一群醉汉，突然一个吼一声“倒酒”（事件），你小跑过去给他倒一杯，
	然后随他去吧，突然又一个要倒酒，你又过去倒上，就这样一个服务员服务好多人，有时没人喝酒，服务员处于空闲状态，
	可以干点别的玩玩手机。至于epoll与select，poll的区别在于后两者的场景中醉汉不说话，你要挨个问要不要酒，没时间
	玩手机了。io多路复用大概就是指这几个醉汉共用一个服务员。
	```
* 2.调度算法：操作系统管理了系统的有限资源，当有多个进程（或多个进程发出的请求）要使用这些资源时，因为资源的有限性，必须按照一定的原则选择进程（请求）来占用资源。这就是调度。
	常见的调度算法：
	* 1.先来先服务(FCFS, First Come First Serve)
	* 2.短作业优先(SJF, Shortest Job First)
	* 3.最高优先权调度(Priority Scheduling)
	* 4.**时间片轮转**(RR, Round Robin)
	* 5.多级反馈队列调度(multilevel feedback queue scheduling)
	* 6.实时调度算法:
		* 1.最早截至时间优先 EDF
		* 2.最低松弛度优先 LLF
* 3.事务：数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，**要么完全地执行，要么完全地不执行**。
	* 1.事务(transaction)所应该具有的四个特性（ACID）：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation） 、持久性（Durability）。
	* 2.MySQL事务操作：
		* START TRANSACTION;开启事务。后面的语句处于同一个事务之中
		* ROLLBACK [TO save_point_name];回滚到指定的保留点，或者开启事务之前，结束事务
		* COMMIT；提交事务,然后结束事务
		* SAVEPOINT；保留点
* 4.Redis：是一个完全开源免费的key-value内存数据库，通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets。
	* 1.把redis当作一个中间存储系统，用来处理高并发的数据库操作。
		* 1.速度快：使用标准C语言编写，所有数据都在内存中完成，读写速度分别达到10万/20万
		* 2.持久化：采用Copy-on-write技术，可以异步地保存到磁盘上。
		* 3.自动操作：对不同数据类型的操作都是自动的，很安全。
		* 4.快速的主--从复制。
		* 5.Sharding技术：这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。
	* 2.Redis缺点：
		* 1.Redis适合的场景主要局限在**较小数据量的高性能操作和运算上**，因为数据库容量受到物理内存的限制,不能用作海量数据的高性能读写。
		* 2.Redis**较难支持在线扩容**，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。

## 四、网络
* 1.三次握手：
	* 1.客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数 A。
	* 2.服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。
	* 3.最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。
* 2.四次挥手：
	* 注意: **中断连接端可以是客户端，也可以是服务器端.** 下面仅以客户端断开连接举例, 反之亦然.
	* 1.客户端发送一个数据分段, 其中的 FIN 标记设置为1. 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据.
	* 2.服务器接收到带有 FIN = 1 的数据分段, 发送带有 ACK = 1 的剩余数据分段, 确认收到客户端发来的 FIN 信息.
	* 3.服务器等到所有数据传输结束, 向客户端发送一个带有 FIN = 1 的数据分段, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK = 1 的确认报文.
	* 4.客户端收到服务器发来带有 FIN = 1 的报文, 返回 ACK = 1 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 2MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接.
* 3.urllib和urllib2的区别：
	* 1.urllib提供urlencode方法用来产生GET查询字符串，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。
	* 2.urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。
* 4.Cookie和Session：

|   \   | Cookie                     | Session |
| :--- | :------------------------- | :------ |
| 储存位置 | 客户端                        | 服务器端    |
| 目的   | 跟踪会话，也可以保存用户偏好设置或者保存用户名密码等 | 跟踪会话    |
| 安全性  | 不安全                        | 安全      |

session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。
* 5.nginx和apache的区别：
	nginx 相对 apache 的**优点**：
	* 轻量级，同样的web 服务，比apache 占用更少的内存及资源
	* 高并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能
	* 配置简洁
	* 高度模块化的设计，编写模块相对简单
	* 社区活跃
	
	apache 相对nginx 的**优点**：
	* rewrite比nginx 的rewrite 强大
	* 模块超多，基本想到的都可以找到
	* 少bug ，nginx 的bug 相对较多
	* 超稳定
* 6.HTTP和HTTPS：

| 状态码       | 定义               |
| :-------- | :--------------- |
| 1xx 报告    | 接收到请求，继续进程       |
| 2xx 成功    | 步骤成功接收，被理解，并被接受  |
| 3xx 重定向   | 为了完成请求,必须采取进一步措施 |
| 4xx 客户端出错 | 请求包括错的顺序或不能完成    |
| 5xx 服务器出错 | 服务器无法完成显然有效的请求   |
403: Forbidden
404: Not Found
HTTPS握手,对称加密,非对称加密,TLS/SSL,RSA
* 7.XSRF（csrf）和XSS：
	* CSRF(Cross-site request forgery)跨站请求伪造，通常缩写为CSRF或者XSRF,即习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。
	* XSS(Cross Site Scripting)跨站脚本攻击
	```
	其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。
	这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。
	```
	CSRF重点在请求,XSS重点在脚本
* 8.CGI和WSGI
	* CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。
	* WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。
* 9.HTTP1.0和HTTP1.1
	* 请求头Host字段,一个服务器多个网站
	* HTTP请求8种方法介绍
	HTTP /1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。
	1.GET
	1.GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。
	GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。
	2.HEAD
	2.HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。
	3.POST
	3.POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。
	4.PUT
	4.PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。
	5.DELETE
	5.DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。
	6.CONNECT
	6.CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。
	7.OPTIONS
	7.OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’\*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许
	8.TRACE
	8.TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。
	**HTTP \/1.1之后增加的方法**
	在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：
	**PATCH**
	PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：
	但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。
	当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。
* 10.socket:
	* ![q](https://i.imgur.com/LLJBcZN.jpg)
	* 1.Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。
	* 2.![s](https://i.imgur.com/BUd3oUK.jpg)
	* 3.先从服务器端说起:服务器端先初始化Socket,然后与端口绑定(bind),对端口进行监听（listen），调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个socket，然后连接服务器（connect），如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。
* 11.浏览器缓存机制：浏览器缓存机制，其实主要就是**HTTP协议定义的缓存机制**（如： Expires； Cache-control等）。
* 12.AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式动态网页应用的网页开发技术。
	* 通过在后台与服务器进行少量数据交换，**AJAX 可以使网页实现异步更新**。这意味着可以在**不重新加载整个网页**的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个网页页面。
* 13.红黑树：
	* 1.红黑树本质上就是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。
	* 2.这就引出了红黑树的5条性质：
		* 1）每个结点要么是红的，要么是黑的。  
		* 2）根结点是黑的。  
		* 3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。  
		* 4）如果一个结点是红的，那么它的俩个儿子都是黑的。  
		* 5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。
		![red](https://i.imgur.com/y8w16Xb.png)
	* 3.红黑树与AVL的比较：
		* AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；
		* 红黑是用非严格的平衡来换取增删节点时候旋转次数的降低；
		* 所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。
* 14.台阶问题/**斐波那契数列Fibonacci**：
	一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。	
	```
	fib = lambda n: n if n <= 2 else fib(n - 1) + fib(n - 2)
	```	
	第二种记忆方法	
	```
	def memo(func):
	    cache = {}
	    def wrap(*args):
	        if args not in cache:
	            cache[args] = func(*args)
	        return cache[args]
	    return wrap
	@memo
	def fib(i):
	    if i < 2:
	        return 1
	    return fib(i-1) + fib(i-2)
	```	
	第三种方法	
	```
	def fib(n):
	    a, b = 0, 1
	    for _ in xrange(n):
	        a, b = b, a + b
	    return b
	```
	* 斐波那契数列的迭代版本,即迭代出第1个值，第2个值，第3个值...
	```
	def fib_iter(n):
		    if n<2: 
				return 1
		    a,b=1,1
		    while n>=2:
		        c=a+b
		        a=b
		        b=c
		        n=n-1
		    return c
	```
* 15.变态台阶问题：
	* 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
	```
	fib = lambda n: n if n < 2 else 2 * fib(n - 1)
	```
* 16.算法-动态规划 Dynamic Programming
	* 1.动态规划算法的核心：就是**记住已经解决过的子问题的解**。
	```
	A * "1+1+1+1+1+1+1+1 =？" *
	A : "上面等式的值是多少"
	B : *计算* "8!"	
	A *在上面等式的左边写上 "1+" *
	A : "此时等式的值为多少"
	B : *quickly* "9!"
	A : "你怎么这么快就知道答案了"
	A : "只要在8的基础上加1就行了"
	A : "所以你不用重新计算因为你记住了第一个等式的值为8!动态规划算法也可以说是 '记住求过的解来节省时间'" 
	```
	* 2.动态规划算法的两种形式：
	```
	# c语言
	public int fib(int n)
	{
	    if(n<=0)
	        return 0;
	    if(n==1)
	        return 1;
	    return fib( n-1)+fib(n-2);
	}
	//输入6
	//输出：8
	```
	![](https://i.imgur.com/XKIh8SR.png)
	上面的递归树中的每一个子节点都会执行一次，很多重复的节点被执行，fib(2)被重复执行了5次。由于调用每一个函数的时候都要保留上下文，所以空间上开销也不小。这么多的子节点被重复执行，如果在执行的时候把**执行过的子节点保存起来**，后面要用到的时候直接查表调用的话可以节约大量的时间。
		* 1..直接**自顶向下实现递归式**，并将中间结果保存，这叫备忘录法；
		* 2.按照递归式**自底向上地迭代**，将结果保存在某个数据结构中求解。
* 17.动态规划常见的问题：
	* 1.求解方法：阶段 + 状态变量 + 状态转移方程 + 边界条件
		* （1）**划分阶段**：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。
		* （2）**确定状态和状态变量**：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
		* （3）**确定决策并写出状态转移方程**：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两段各状态之间的关系来确定决策。
		* （4）**寻找边界条件**：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。 
	* 2.假设有 1 元， 3 元， 5 元的硬币若干（无限），现在需要凑出 11 元，问如何组合才能使硬币的数量最少？
	```
	# 动态规划思想  dp方程式如下
	# dp[0] = 0
	# dp[i] = min{dp[i - coins[j]] + 1}, 且 其中 i >= coins[j], 0 <= j < coins.length
	# 回溯法，输出可找的硬币方案
	# path[i] 表示经过本次兑换后所剩下的面值，即 i - path[i] 可得到本次兑换的硬币值。  
	def changeCoins(coins, n):    
			if n < 0: 
				return None  
			dp, path = [0] * (n + 1), [0] * (n + 1)  # 初始化    
			for i in range(1, n + 1):        
				minNum = i  # 初始化当前硬币最优值        
				for c in coins:  # 扫描一遍硬币列表，选择一个最优值  
					if i >= c and minNum > dp[i - c] + 1: 
						minNum, path[i] = dp[i - c] + 1, i - c
		        dp[i] = minNum  # 更新当前硬币最优值
	    	print('最少硬币数:', dp[-1])
		    print('可找的硬币', end=': ')    
			while path[n] != 0:
		        print(n - path[n], end=' ')
		        n = path[n]    print(n, end=' ')
	if __name__ == '__main__':
		    coins, n = [1, 3, 5], 11  # 输入可换的硬币种类，总金额n    
			changeCoins(coins, n)
	```
* 18.




